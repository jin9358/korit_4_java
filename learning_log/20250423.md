# 형변환(Conversion)
## 정의
- 형변환(Type Conversion)이란 프로그램에서 서로 다른 자료형(Type) 간의 값을 주고 받을 때 발생하는
    데이터 표현 방식의 차이를 보정하기 위해 값을 적절히 변환하는 작업
- 예를 들어 32비트 정수(int) 값을 64비트 정수(long) 변수에 담거나, 반대로 64비트 값을 32비트 변수에
    담으려면 반드시 변환 과정을 거쳐야만 함.

  ## 필요성
1. 메모리 최적화
    - 작은 타입에만 저장해도 충분한 값이라면, 더 큰 타입을 쓰는 것은 메모리 낭비이기 떄문에.
    - 반대로, 큰 범위의 값이 필요할 때 작은 타입으로만 프로그램을 짜면 표현할 수 없는 값이 생깁니다.
2. API 호환성
    - 예를 들어, 외부 라이브러리 메서드가 'long'을 받아들일 때, 우리 서쪽에서 'int' 값을 넘기면 자동
      (암시적)으로  'long'으로 변환해줘야 합니다.
3. 연산 정확도
    - 소수점 연산을 위해 `float->double`으로 확장하거나, 반대로 저장 공간을 줄이기 ㅣ위해
        `double->float`으로 축소하는 사례가 많습니다(이모지 사용법 : window + .)
    - 
# 업캐스팅(Upcasting) vs. 다운캐스팅(Downcasting)
## 업캐스팅(Upcasting, Widening Conversion)
### 정의
- 메모리 용량(비트 크기)이 작은 타입 -> 더 큰 타입으로 변환
### 특징
- 메모리 여유가 생기므로, 원본 값이 손실 없이 모두 표현 가능
- 암시적(implicit) 변환이 기본 제공

# 다운캐스팅(Downcasting, Narrowing Conversion)
### 정의
- 메모리 용량이 큰 타입 -> 더 작은 타입으로 변환

### 특징
- 표현할 수 있는 값의 범위가 줄어들기 때문에, 변환 과정에서 데이터 손실(oveerflow/underflow)위험 발생
- 따라서 명시적(explicit) 캐스트 연산자로만 수행 가능함.

| 타입   | 크기 (bits) | 부호     | 표현 범위                                      | 비고                         |
|:------:|:-----------:|:--------:|:-----------------------------------------------|:-----------------------------|
| byte   | 8           | ✔︎       | -128 ~ 127                                     | 정수형 최소 단위             |
| short  | 16          | ✔︎       | -32,768 ~ 32,767                               |                              |
| char   | 16          | ✘        | 0 ~ 65,535                                     | 유니코드 문자 저장 용도      |
| int    | 32          | ✔︎       | -2³¹ ~ 2³¹-1                                   | 약 -21억 ~ +21억             |
| long   | 64          | ✔︎       | -2⁶³ ~ 2⁶³-1                                   | 약 -9.22×10¹⁸ ~ +9.22×10¹⁸   |
| float  | 32          | IEEE 754 | 약 ±1.4×10⁻⁴⁵ ~ ±3.4×10³⁸ (유효숫자 ≈ 7자리)     | 단정도 (single-precision)    |
| double | 64          | IEEE 754 | 약 ±4.9×10⁻³²⁴ ~ ±1.7×10³⁰⁸ (유효숫자 ≈ 15자리) | 배정도 (double-precision)    |

# 조건문(Condition)
조건문
1. if문 : if 다음에 있는 () 내의 조건식이 true일 때 {} 내의 실행문이 실행됨.
    false면 실행 x

2. if - else문 : if 다음에 있는 조건식이 true일 때는 if문 내의 {} 실행문이 실행
   / false인 경우에는 else에 딸린 {} 실행문이 실행

3. if - else if문 : if - else문과 달리 else if에는 별도의 조건식이 요구됨
   그리고 else if는 여러 개 나올 수 있습니다.

4. if - else if - else문

5.  중첩 if문(Nested - if)
    if 문 내에 if문이 연속적으로 작성될 수 있습니다.

### 조건문 작성시 주의할점
- 조건은 널널한 것으로부터 촘촘한 것으로 좁혀들어가야 오류가 발생하지 않을 겁니다.

조건문이 길어질 시 삼항연산자 / 논리연산자를 사용해 줄일 수 있음
```java
// ex)
    if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)){
    leapYear = "윤년입니다.";
    } else {             
    leapYear = "윤년이 아닙니다";
    }
```

## while 반복문
```
형식 :
while(조건식) {
반복실행문
}
```
while 뒤에 나오는 (조건식)을 봤을 때 if(조건식) 형태와 유사
즉, while() 내의 조건식이 true일 때, {} 내의 실행문이 '반복'

### 주의할 점
while 내부의 조건식이 특정 시점에 false가 되도록 미리 지정해둘 필요가
있습니다. 
- 무한 루프에 걸리지 않도록 주의

## 중첩 while문
```java
while(조건식1) {
반복실행문1-a
while(조건식2) {
반복실행문2
}

// ex) 구구단
int dan = 2;
        while(dan < 10) {
int num = 1;
            while (num < 10) {
        System.out.println(dan + " x " + num + " = " + (dan*num));
num++;
        }
dan++;
        }
```

##  for 반복문
- 명확한 횟수가 고정되어 있을 때 사용하는 반복문
```java
형식 :
    for(시작값 ; 종료값 ; 증감값) {
        반복실행문
    }
// ex) 1부터 입력받은 수까지 더하는 반복문 
/*
            실행 예
            1부터 몇 까지 더하시겠습니까? >>> 10
            1부터 10까지의 합은 55입니다.
         */
Scanner scanner = new Scanner(System.in);
        System.out.print("1부터 몇 까지 더하시겠습니까? >>> ");
int n = scanner.nextInt();
int sumN = 0;

//        for (int i = 0 ; i <= n ; i++) {
//            sumN += i;
//        }
        for (int i = 0 ; i < n + 1 ; i++) {
sumN += i;
        }
                System.out.println("1부터 " + n + "까지의 합은 " + sumN + "입니다.");
```

### for문도 중첩 가능
```java
for (int i = 0 ; i < 10 ; i ++) {
        (반복실행문1-a)
        for(int j = 0 ; j < 10 ; j ++) {
            반복실행문2
        }
        (반복실행문1-b)
        for(int k = 0 ; k < 10 ; k++) {
            반복실행문3
        }
        (반복실행문1-c)
    }
```